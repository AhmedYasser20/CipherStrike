import os
import yara


def classify_ransomware(matches):
    """
    Determine if a file is likely ransomware based on weighted rule matches
    Returns: (is_ransomware, confidence_level, reasoning)
    """
    if not matches:
        return False, 0, "No suspicious indicators detected"
    
    # Feature weights (importance of each rule type)
    weights = {
        "Ransomware_Hardcoded_Commands": 0.95,    # Very strong indicator
        "Ransomware_String_Indicators": 0.90,     # Very strong indicator
        "Ransomware_Crypto_Usage": 0.75,          # Strong indicator
        "Ransomware_Suspicious_API_Calls": 0.70,  # Strong indicator
        "Ransomware_File_Drive_Access": 0.65,     # Moderate-strong indicator
        "Ransomware_DLL_Imports": 0.55,           # Moderate indicator
        "Ransomware_Anti_Debug_Evasion": 0.40,    # Weak-moderate indicator
        "Ransomware_Registry_Operations": 0.45,   # Weak-moderate indicator
        "Ransomware_PE_Sections": 0.30,           # Weak indicator
        "Ransomware_High_Entropy": 0.25           # Weak indicator
    }
    
    # Extract matched rules
    matched_rules = [match.rule for match in matches]
    
    # Calculate base confidence from matched rules
    base_confidence = 0
    for rule in matched_rules:
        if rule in weights:
            base_confidence += weights[rule]
    
    # Cap at 1.0 and convert to percentage
    base_confidence = min(base_confidence, 1.0) * 100
    
    # Apply combination bonuses for specific rule combinations
    combination_bonus = 0
    reasoning = []
    
    # Critical indicators
    if "Ransomware_Hardcoded_Commands" in matched_rules:
        reasoning.append("Contains commands to disable system recovery")
        combination_bonus += 20
    
    if "Ransomware_String_Indicators" in matched_rules:
        reasoning.append("Contains ransom notes or cryptocurrency references")
        combination_bonus += 15
        
    # Strong evidence combinations
    if "Ransomware_Crypto_Usage" in matched_rules and "Ransomware_File_Drive_Access" in matched_rules:
        reasoning.append("Uses cryptographic functions combined with mass file access")
        combination_bonus += 25
    
    if "Ransomware_DLL_Imports" in matched_rules and "Ransomware_Crypto_Usage" in matched_rules:
        reasoning.append("Imports crypto libraries and uses crypto functions")
        combination_bonus += 20
        
    if "Ransomware_Suspicious_API_Calls" in matched_rules and "Ransomware_Registry_Operations" in matched_rules:
        reasoning.append("Modifies registry while using suspicious API calls")
        combination_bonus += 15
    
    # Broader combinations
    matched_count = len(matched_rules)
    if matched_count >= 5:
        reasoning.append(f"Matched {matched_count} different ransomware indicators")
        combination_bonus += 25
    elif matched_count >= 3:
        reasoning.append(f"Matched {matched_count} different ransomware indicators")
        combination_bonus += 10
    
    # Calculate final confidence score
    final_confidence = min(base_confidence + combination_bonus, 100)
    
    # Determine ransomware classification
    is_ransomware = False
    if final_confidence >= 85:
        is_ransomware = True
        classification = "HIGH CONFIDENCE RANSOMWARE"
    elif final_confidence >= 70:
        is_ransomware = True
        classification = "LIKELY RANSOMWARE"
    elif final_confidence >= 50:
        is_ransomware = False  # Not definitively ransomware
        classification = "SUSPICIOUS - POSSIBLE RANSOMWARE"
    else:
        is_ransomware = False
        classification = "LOW CONFIDENCE - LIKELY NOT RANSOMWARE"
    
    # Join reasoning points
    reasoning_text = "; ".join(reasoning) if reasoning else "Multiple suspicious indicators"
    
    return is_ransomware, final_confidence, classification, reasoning_text

def find_exe_files(directory="."):
    """Find all exe files in the specified directory"""
    exe_files = []
    for file in os.listdir(directory):
        if file.lower().endswith(".exe"):
            exe_files.append(os.path.join(directory, file))
    return exe_files

def scan_files(files, rules_path):
    """Scan files using YARA rules"""
    try:
        # Compile YARA rules
        rules = yara.compile(filepath=rules_path)
        
        print(f"Starting scan of {len(files)} exe files...")
        print("-" * 60)
        
        results = {}
        for file_path in files:
            try:
                # Get filename for display
                filename = os.path.basename(file_path)
                print(f"Scanning {filename}...", end="", flush=True)
                
                # Scan the file
                matches = rules.match(file_path)
                
                if matches:
                    # Calculate total risk score
                    total_score = sum(match.meta.get('score', 0) for match in matches)
                    print(f" [SUSPICIOUS] Risk Score: {total_score}")
                    results[file_path] = {
                        'matches': matches,
                        'total_score': total_score
                    }
                else:
                    print(" [CLEAN]")
            
            except Exception as e:
                print(f" [ERROR: {str(e)}]")
        
        return results
    
    except Exception as e:
        print(f"Error compiling rules: {str(e)}")
        return {}

def get_risk_level(score):
    """Convert numeric score to risk level"""
    if score >= 150:
        return "CRITICAL"
    elif score >= 100:
        return "HIGH"
    elif score >= 50:
        return "MEDIUM"
    else:
        return "LOW"

def display_results(scan_results):
    """Display formatted scan results"""
    print("\n" + "=" * 60)
    print("SCAN RESULTS")
    print("=" * 60)
    
    if not scan_results:
        print("No suspicious files detected.")
        return
    
    suspicious_count = len(scan_results)
    print(f"Found {suspicious_count} suspicious file(s):\n")
    
    # Sort results by total score (highest first)
    sorted_results = sorted(scan_results.items(), key=lambda x: x[1]['total_score'], reverse=True)
    
    for file_path, result_data in sorted_results:
        matches = result_data['matches']
        total_score = result_data['total_score']
        risk_level = get_risk_level(total_score)
        
        # Perform ransomware classification
        is_ransomware, confidence, classification, reasoning = classify_ransomware(matches)
        
        filename = os.path.basename(file_path)
        print(f"[!] {filename}")
        print(f"  Path: {file_path}")
        print(f"  Risk Assessment: {risk_level} (Score: {total_score})")
        print(f"  Ransomware Classification: {classification} ({confidence:.1f}% confidence)")
        print(f"  Analysis: {reasoning}")
        print(f"  Matched rules:")
        
        # Sort matches by score (highest first)
        sorted_matches = sorted(matches, key=lambda x: x.meta.get('score', 0), reverse=True)
        
        for match in sorted_matches:
            score = match.meta.get('score', 'N/A')
            print(f"    - {match.rule} (Score: {score}, Severity: {match.meta.get('severity', 'unknown')})")
            print(f"      {match.meta.get('description', 'No description')}")
            # Display matched strings - FIXED FOR NEWER YARA-PYTHON VERSIONS
            if hasattr(match, 'strings') and match.strings:
                print(f"      Matched patterns:")
                for string_match in match.strings:
                    try:
                        # Get the string identifier (name)
                        identifier = string_match.identifier
                        
                        # Process each instance of this string match
                        for instance in string_match.instances:
                            offset = instance.offset
                            matched_data = instance.matched_data
                            
                            # Try to decode bytes to string if possible
                            try:
                                if isinstance(matched_data, bytes):
                                    string_data = matched_data.decode('utf-8', errors='replace')
                                else:
                                    string_data = str(matched_data)
                                
                                # Truncate very long strings
                                if len(string_data) > 60:
                                    string_data = string_data[:57] + "..."
                                    
                                print(f"        - {identifier}: \"{string_data}\" at offset {offset}")
                            except:
                                print(f"        - {identifier}: [Binary data] at offset {offset}")
                    except AttributeError:
                        # Fallback for different YARA-Python versions
                        print(f"        - {string_match}")
        print()

def main():
    """Main function"""
    # Path to YARA rules file (in the same directory as the script)
    script_dir = os.path.dirname(os.path.abspath(__file__))
    rules_path = os.path.join(script_dir, "rules2.yar")
    
    # Check if rules file exists
    if not os.path.exists(rules_path):
        print(f"Error: Rules file not found at {rules_path}")
        return
    
    # Find all exe files
    exe_files = find_exe_files()
    
    if not exe_files:
        print("No executable files found in the current directory.")
        return
    
    # Scan files
    results = scan_files(exe_files, rules_path)
    
    # Display results
    display_results(results)

if __name__ == "__main__":
    main()