import os
import sys
import yara
import math
import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext
from tkinter import messagebox
import threading
import time
from datetime import datetime

def resource_path(relative_path):
    """Get absolute path to resource, works for dev and for PyInstaller"""
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(os.path.dirname(__file__))

    return os.path.join(base_path, relative_path)

class RansomwareScannerGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("CipherStrike Ransomware Scanner")
        self.root.geometry("900x700")
        self.root.minsize(800, 600)
        
        # Set theme colors
        self.bg_color = "#f0f0f0"
        self.header_color = "#2c3e50"
        self.text_color = "#ecf0f1"
        self.accent_color = "#3498db"
        self.warning_color = "#e74c3c"
        
        self.root.configure(bg=self.bg_color)
        
        # Set icon if available
        try:
            self.root.iconbitmap(resource_path("shield.ico"))
        except:
            pass
        
        # Set the rules path to the bundled file
        self.rules_path = resource_path("rules3.yar")
        
        self.setup_ui()
    
    # Move these methods inside the class
    def browse_folder(self):
        """Open a directory dialog to select the folder to scan"""
        folder = filedialog.askdirectory(initialdir=self.folder_path.get())
        if folder:
            self.folder_path.set(folder)

    def create_summary_label(self, parent, label_text, value_text, row):
        """Helper method to create a label pair for the summary section"""
        frame = tk.Frame(parent, bg=self.bg_color)
        frame.grid(row=row, column=0, sticky="w", pady=2)
        
        label = tk.Label(frame, text=label_text, bg=self.bg_color, font=("Arial", 10, "bold"), width=20, anchor="w")
        label.pack(side=tk.LEFT)
        
        value = tk.Label(frame, text=value_text, bg=self.bg_color, font=("Arial", 10))
        value.pack(side=tk.LEFT)
        
        return value

    def stop_scan(self):
        """Stop the running scan"""
        if self.scanning:
            self.scanning = False
            self.status_var.set("Scan stopped by user.")
            self.log("Scan stopped by user.")
            self.progress.stop()
            self.scan_btn.config(state=tk.NORMAL)
            self.stop_btn.config(state=tk.DISABLED)

    def clear_results(self):
        """Clear all result displays"""
        self.summary_text.delete(1.0, tk.END)
        self.result_text.delete(1.0, tk.END)
        self.log_text.delete(1.0, tk.END)
        # Reset summary labels
        for key, label in self.summary_labels.items():
            if key == "scan_time":
                label.config(text="N/A")
            else:
                label.config(text="0")

    def log(self, message):
        """Add a message to the log with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.log_text.see(tk.END)
        
    # Keep the rest of your class methods as they were
    def __init__(self, root):
        self.root = root
        self.root.title("CipherStrike Ransomware Scanner")
        self.root.geometry("900x700")
        self.root.minsize(800, 600)
        
        # Set theme colors
        self.bg_color = "#f0f0f0"
        self.header_color = "#2c3e50"
        self.text_color = "#ecf0f1"
        self.accent_color = "#3498db"
        self.warning_color = "#e74c3c"
        
        self.root.configure(bg=self.bg_color)
        
        # Set icon if available
        try:
            self.root.iconbitmap(resource_path("shield.ico"))
        except:
            pass
        
        # Set the rules path to the bundled file
        self.rules_path = resource_path("rules3.yar")
        
        self.setup_ui()
        
    def setup_ui(self):
        # Create header frame
        header_frame = tk.Frame(self.root, bg=self.header_color, height=60)
        header_frame.pack(fill=tk.X)
        header_label = tk.Label(
            header_frame, 
            text="CipherStrike Ransomware Scanner", 
            font=("Arial", 18, "bold"),
            bg=self.header_color,
            fg=self.text_color,
            pady=10
        )
        header_label.pack()
        
        # Create input frame
        input_frame = tk.Frame(self.root, bg=self.bg_color, pady=10)
        input_frame.pack(fill=tk.X, padx=20)
        
        # Folder selection
        tk.Label(input_frame, text="Select folder to scan:", bg=self.bg_color).grid(row=0, column=0, padx=5, pady=10, sticky="w")
        self.folder_path = tk.StringVar(value=os.getcwd())
        folder_entry = tk.Entry(input_frame, textvariable=self.folder_path, width=50)
        folder_entry.grid(row=0, column=1, padx=5, pady=10)
        browse_btn = tk.Button(
            input_frame, 
            text="Browse", 
            command=self.browse_folder,
            bg=self.accent_color,
            fg=self.text_color,
            relief=tk.FLAT,
            padx=10
        )
        browse_btn.grid(row=0, column=2, padx=5, pady=10)
        
        # Scan options frame
        options_frame = tk.LabelFrame(self.root, text="Scan Options", bg=self.bg_color, padx=10, pady=5)
        options_frame.pack(fill=tk.X, padx=20, pady=5)
        
        # Option to include subdirectories
        self.include_subdirs = tk.BooleanVar(value=True)
        subdir_check = tk.Checkbutton(
            options_frame, 
            text="Include subdirectories",
            variable=self.include_subdirs,
            bg=self.bg_color
        )
        subdir_check.grid(row=0, column=0, sticky="w", padx=5)
        
        # Action buttons
        btn_frame = tk.Frame(self.root, bg=self.bg_color)
        btn_frame.pack(fill=tk.X, padx=20, pady=10)
        
        self.scan_btn = tk.Button(
            btn_frame,
            text="Start Scan",
            command=self.start_scan,
            bg="#27ae60",  # Green
            fg=self.text_color,
            relief=tk.FLAT,
            font=("Arial", 12, "bold"),
            padx=20,
            pady=5
        )
        self.scan_btn.pack(side=tk.LEFT, padx=5)
        
        self.stop_btn = tk.Button(
            btn_frame,
            text="Stop Scan",
            command=self.stop_scan,
            bg=self.warning_color,
            fg=self.text_color,
            relief=tk.FLAT,
            state=tk.DISABLED,
            font=("Arial", 12),
            padx=20,
            pady=5
        )
        self.stop_btn.pack(side=tk.LEFT, padx=5)
        
        clear_btn = tk.Button(
            btn_frame,
            text="Clear Results",
            command=self.clear_results,
            bg=self.accent_color,
            fg=self.text_color,
            relief=tk.FLAT,
            font=("Arial", 12),
            padx=20,
            pady=5
        )
        clear_btn.pack(side=tk.LEFT, padx=5)
        
        # Status frame
        status_frame = tk.Frame(self.root, bg=self.bg_color)
        status_frame.pack(fill=tk.X, padx=20, pady=5)
        
        self.status_var = tk.StringVar(value="Ready")
        status_label = tk.Label(
            status_frame, 
            textvariable=self.status_var, 
            bg=self.bg_color,
            anchor="w"
        )
        status_label.pack(side=tk.LEFT)
        
        self.progress = ttk.Progressbar(status_frame, mode="indeterminate", length=200)
        self.progress.pack(side=tk.RIGHT, padx=5)
        
        # Results notebook with tabs
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Summary tab
        summary_frame = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(summary_frame, text="Summary")
        
        # Summary info frame
        self.summary_info = tk.Frame(summary_frame, bg=self.bg_color)
        self.summary_info.pack(fill=tk.X, pady=10)
        
        # Initialize summary labels
        self.summary_labels = {
            "scan_time": self.create_summary_label(self.summary_info, "Scan Time:", "N/A", 0),
            "files_scanned": self.create_summary_label(self.summary_info, "Files Scanned:", "0", 1),
            "suspicious_files": self.create_summary_label(self.summary_info, "Suspicious Files:", "0", 2),
            "ransomware_files": self.create_summary_label(self.summary_info, "Ransomware Detected:", "0", 3)
        }
        
        # Summary results frame - will contain the highest risk files
        summary_results_frame = tk.LabelFrame(summary_frame, text="Highest Risk Files", bg=self.bg_color)
        summary_results_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.summary_text = scrolledtext.ScrolledText(summary_results_frame, wrap=tk.WORD)
        self.summary_text.pack(fill=tk.BOTH, expand=True)
        
        # Detailed results tab
        details_frame = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(details_frame, text="Detailed Results")
        
        self.result_text = scrolledtext.ScrolledText(details_frame, wrap=tk.WORD)
        self.result_text.pack(fill=tk.BOTH, expand=True)
        
        # Log tab
        log_frame = tk.Frame(notebook, bg=self.bg_color)
        notebook.add(log_frame, text="Log")
        
        self.log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD)
        self.log_text.pack(fill=tk.BOTH, expand=True)
        
        # Initialize scanning state
        self.scanning = False
        self.scan_thread = None
        
   

    def start_scan(self):
        if not os.path.exists(self.folder_path.get()):
            messagebox.showerror("Error", "Selected folder does not exist.")
            return
        
        if not os.path.exists(self.rules_path):
            messagebox.showerror("Error", "YARA rules file not found. Make sure 'rules3.yar' is in the same directory as the application.")
            return
        
        self.scanning = True
        self.scan_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)
        self.progress.start()
        self.status_var.set("Scanning...")
        
        # Clear previous results
        self.clear_results()
        
        # Start scan in a separate thread
        self.scan_thread = threading.Thread(target=self.run_scan)
        self.scan_thread.daemon = True
        self.scan_thread.start()
    
    def run_scan(self):
        start_time = time.time()
        
        try:
            # Compile YARA rules
            self.log(f"Compiling bundled YARA rules")
            rules = yara.compile(filepath=self.rules_path)
            # Find executable files
            self.log(f"Searching for executable files in {self.folder_path.get()}")
            exe_files = self.find_exe_files(self.folder_path.get(), self.include_subdirs.get())
            
            if not exe_files:
                self.log("No executable files found.")
                self.root.after(0, lambda: self.status_var.set("No executable files found."))
                self.root.after(0, self.progress.stop)
                self.root.after(0, lambda: self.scan_btn.config(state=tk.NORMAL))
                self.root.after(0, lambda: self.stop_btn.config(state=tk.DISABLED))
                self.scanning = False
                return
            
            self.log(f"Found {len(exe_files)} executable files to scan.")
            
            # Update UI from the main thread
            self.root.after(0, lambda: self.summary_labels["files_scanned"].config(text=str(len(exe_files))))
            
            # Scan files
            results = {}
            suspicious_count = 0
            ransomware_count = 0
            
            for i, file_path in enumerate(exe_files):
                if not self.scanning:  # Check if scan was stopped
                    break
                
                filename = os.path.basename(file_path)
                self.log(f"Scanning {filename}...")
                self.root.after(0, lambda: self.status_var.set(f"Scanning {i+1}/{len(exe_files)}: {filename}"))
                
                try:
                    # Scan the file
                    matches = rules.match(file_path)
                    
                    # Calculate entropy
                    entropy = self.calculate_entropy(file_path)
                    entropy_score = 0
                    if entropy > 8.5:
                        entropy_score = 25
                    elif entropy > 7.5:
                        entropy_score = 10
                    
                    if matches:
                        # Calculate total risk score
                        total_score = sum(match.meta.get('score', 0) for match in matches) + entropy_score
                        self.log(f"[SUSPICIOUS] {filename} - Risk Score: {total_score}")
                        
                        suspicious_count += 1
                        
                        # Check if ransomware
                        ransomware_threshold = 100
                        if total_score >= ransomware_threshold:
                            self.log(f"[RANSOMWARE DETECTED] {filename} - Risk Score: {total_score}")
                            ransomware_count += 1
                        
                        results[file_path] = {
                            'matches': matches,
                            'total_score': total_score,
                            'entropy': entropy
                        }
                
                except Exception as e:
                    self.log(f"Error scanning {filename}: {str(e)}")
            
            end_time = time.time()
            scan_duration = end_time - start_time
            
            # Update summary
            self.root.after(0, lambda: self.summary_labels["scan_time"].config(text=f"{scan_duration:.2f} seconds"))
            self.root.after(0, lambda: self.summary_labels["suspicious_files"].config(text=str(suspicious_count)))
            self.root.after(0, lambda: self.summary_labels["ransomware_files"].config(text=str(ransomware_count)))
            
            # Display results
            self.display_results(results)
            
            # Scan finished
            self.log(f"Scan completed in {scan_duration:.2f} seconds.")
            self.root.after(0, lambda: self.status_var.set(f"Scan completed. Found {suspicious_count} suspicious files."))
            
        except Exception as e:
            self.log(f"Error during scan: {str(e)}")
            self.root.after(0, lambda: self.status_var.set(f"Error: {str(e)}"))
        
        finally:
            # Reset UI state
            self.root.after(0, self.progress.stop)
            self.root.after(0, lambda: self.scan_btn.config(state=tk.NORMAL))
            self.root.after(0, lambda: self.stop_btn.config(state=tk.DISABLED))
            self.scanning = False
    
    def find_exe_files(self, directory, include_subdirs=True):
        """Find all executable files in the specified directory"""
        exe_files = []
        
        if include_subdirs:
            for root, dirs, files in os.walk(directory):
                for file in files:
                    if file.lower().endswith((".exe", ".dll", ".sys")):
                        exe_files.append(os.path.join(root, file))
        else:
            for file in os.listdir(directory):
                if file.lower().endswith((".exe", ".dll", ".sys")):
                    exe_files.append(os.path.join(directory, file))
        
        return exe_files
    
    def calculate_entropy(self, file_path):
        """Calculate the Shannon entropy of a file."""
        try:
            with open(file_path, "rb") as f:
                data = f.read()
                if not data:
                    return 0.0
                byte_counts = [0] * 256
                for byte in data:
                    byte_counts[byte] += 1
                entropy = 0.0
                for count in byte_counts:
                    if count > 0:
                        probability = count / len(data)
                        entropy -= probability * math.log2(probability)
                return entropy
        except Exception as e:
            self.log(f"Error calculating entropy for {file_path}: {e}")
            return 0.0
    
    def classify_ransomware(self, matches):
        """
        Determine if a file is likely ransomware based on weighted rule matches
        Returns: (is_ransomware, confidence_level, classification, reasoning)
        """
        if not matches:
            return False, 0, "No suspicious indicators detected", ""
        
        # Feature weights (importance of each rule type)
        weights = {
            "Ransomware_Hardcoded_Commands": 0.95,    # Very strong indicator
            "Ransomware_String_Indicators": 0.90,     # Very strong indicator
            "Ransomware_Crypto_Usage": 0.75,          # Strong indicator
            "Ransomware_Suspicious_API_Calls": 0.70,  # Strong indicator
            "Ransomware_File_Drive_Access": 0.65,     # Moderate-strong indicator
            "Ransomware_DLL_Imports": 0.55,           # Moderate indicator
            "Ransomware_Anti_Debug_Evasion": 0.40,    # Weak-moderate indicator
            "Ransomware_Registry_Operations": 0.45,   # Weak-moderate indicator
            "Ransomware_PE_Sections": 0.30,           # Weak indicator
            "Ransomware_High_Entropy": 0.25           # Weak indicator
        }
        
        # Extract matched rules
        matched_rules = [match.rule for match in matches]
        
        # Calculate base confidence from matched rules
        base_confidence = 0
        for rule in matched_rules:
            if rule in weights:
                base_confidence += weights[rule]
        
        # Cap at 1.0 and convert to percentage
        base_confidence = min(base_confidence, 1.0) * 100
        
        # Apply combination bonuses for specific rule combinations
        combination_bonus = 0
        reasoning = []
        
        # Critical indicators
        if "Ransomware_Hardcoded_Commands" in matched_rules:
            reasoning.append("Contains commands to disable system recovery")
            combination_bonus += 20
        
        if "Ransomware_String_Indicators" in matched_rules:
            reasoning.append("Contains ransom notes or cryptocurrency references")
            combination_bonus += 15
            
        # Strong evidence combinations
        if "Ransomware_Crypto_Usage" in matched_rules and "Ransomware_File_Drive_Access" in matched_rules:
            reasoning.append("Uses cryptographic functions combined with mass file access")
            combination_bonus += 25
        
        if "Ransomware_DLL_Imports" in matched_rules and "Ransomware_Crypto_Usage" in matched_rules:
            reasoning.append("Imports crypto libraries and uses crypto functions")
            combination_bonus += 20
            
        if "Ransomware_Suspicious_API_Calls" in matched_rules and "Ransomware_Registry_Operations" in matched_rules:
            reasoning.append("Modifies registry while using suspicious API calls")
            combination_bonus += 15
        
        # Broader combinations
        matched_count = len(matched_rules)
        if matched_count >= 5:
            reasoning.append(f"Matched {matched_count} different ransomware indicators")
            combination_bonus += 25
        elif matched_count >= 3:
            reasoning.append(f"Matched {matched_count} different ransomware indicators")
            combination_bonus += 10
        
        # Calculate final confidence score
        final_confidence = min(base_confidence + combination_bonus, 100)
        
        # Determine ransomware classification
        is_ransomware = False
        if final_confidence >= 85:
            is_ransomware = True
            classification = "HIGH CONFIDENCE RANSOMWARE"
        elif final_confidence >= 70:
            is_ransomware = True
            classification = "LIKELY RANSOMWARE"
        elif final_confidence >= 50:
            is_ransomware = False  # Not definitively ransomware
            classification = "SUSPICIOUS - POSSIBLE RANSOMWARE"
        else:
            is_ransomware = False
            classification = "LOW CONFIDENCE - LIKELY NOT RANSOMWARE"
        
        # Join reasoning points
        reasoning_text = "; ".join(reasoning) if reasoning else "Multiple suspicious indicators"
        
        return is_ransomware, final_confidence, classification, reasoning_text
    
    def get_risk_level(self, score):
        """Convert numeric score to risk level"""
        if score >= 150:
            return "CRITICAL"
        elif score >= 100:
            return "HIGH"
        elif score >= 50:
            return "MEDIUM"
        else:
            return "LOW"
    
    def display_results(self, scan_results):
        """Display formatted scan results in the GUI"""
        if not scan_results:
            self.result_text.insert(tk.END, "No suspicious files detected.\n")
            self.summary_text.insert(tk.END, "No suspicious files detected.\n")
            return
        
        # Sort results by total score (highest first)
        sorted_results = sorted(scan_results.items(), key=lambda x: x[1]['total_score'], reverse=True)
        
        # Display all high risk files in the summary tab (not just top 5)
        self.summary_text.insert(tk.END, "All suspicious files (sorted by risk):\n\n")

    # Change from sorted_results[:5] to sorted_results to show all files
        for i, (file_path, result_data) in enumerate(sorted_results):
            matches = result_data['matches']
            total_score = result_data['total_score']
            risk_level = self.get_risk_level(total_score)
            
            # Classify ransomware
            is_ransomware, confidence, classification, reasoning = self.classify_ransomware(matches)
            
            filename = os.path.basename(file_path)
            
            self.summary_text.insert(tk.END, f"{i+1}. {filename}\n")
            self.summary_text.insert(tk.END, f"   Risk: {risk_level} (Score: {total_score})\n")
            self.summary_text.insert(tk.END, f"   Classification: {classification} ({confidence:.1f}% confidence)\n")
            self.summary_text.insert(tk.END, f"   Analysis: {reasoning}\n\n")
        
        for file_path, result_data in sorted_results:
            matches = result_data['matches']
            total_score = result_data['total_score']
            entropy = result_data.get('entropy', 'N/A')
            risk_level = self.get_risk_level(total_score)
            
            # Classify ransomware
            is_ransomware, confidence, classification, reasoning = self.classify_ransomware(matches)
            
            filename = os.path.basename(file_path)
            
            # Add color formatting by inserting tags
            self.result_text.insert(tk.END, f"[!] {filename}\n")
            self.result_text.insert(tk.END, f"  Path: {file_path}\n")
            self.result_text.insert(tk.END, f"  Risk Assessment: {risk_level} (Score: {total_score})\n")
            self.result_text.insert(tk.END, f"  File Entropy: {entropy:.2f}\n")
            self.result_text.insert(tk.END, f"  Ransomware Classification: {classification} ({confidence:.1f}% confidence)\n")
            self.result_text.insert(tk.END, f"  Analysis: {reasoning}\n")
            self.result_text.insert(tk.END, f"  Matched rules:\n")
            
            # Sort matches by score (highest first)
            sorted_matches = sorted(matches, key=lambda x: x.meta.get('score', 0), reverse=True)
            
            for match in sorted_matches:
                score = match.meta.get('score', 'N/A')
                self.result_text.insert(tk.END, f"    - {match.rule} (Score: {score}, Severity: {match.meta.get('severity', 'unknown')})\n")
                self.result_text.insert(tk.END, f"      {match.meta.get('description', 'No description')}\n")
                
                # Display matched strings
                # if hasattr(match, 'strings') and match.strings:
                #     self.result_text.insert(tk.END, f"      Matched patterns:\n")
                #     for string_match in match.strings:
                #         try:
                #             # Get the string identifier (name)
                #             identifier = string_match.identifier
                            
                #             # Process each instance of this string match
                #             for instance in string_match.instances:
                #                 offset = instance.offset
                #                 matched_data = instance.matched_data
                                
                #                 # Try to decode bytes to string if possible
                #                 try:
                #                     if isinstance(matched_data, bytes):
                #                         string_data = matched_data.decode('utf-8', errors='replace')
                #                     else:
                #                         string_data = str(matched_data)
                                    
                #                     # Truncate very long strings
                #                     if len(string_data) > 60:
                #                         string_data = string_data[:57] + "..."
                                        
                #                     self.result_text.insert(tk.END, f"        - {identifier}: \"{string_data}\" at offset {offset}\n")
                #                 except:
                #                     self.result_text.insert(tk.END, f"        - {identifier}: [Binary data] at offset {offset}\n")
                #         except AttributeError:
                #             # Fallback for different YARA-Python versions
                #             self.result_text.insert(tk.END, f"        - {string_match}\n")
            
            self.result_text.insert(tk.END, "\n")
            self.result_text.see("1.0")

def main():
    root = tk.Tk()
    app = RansomwareScannerGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()