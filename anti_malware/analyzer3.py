#!/usr/bin/env python3
"""
Ransomware Scanner
-----------------
A tool to scan executables for ransomware characteristics using static analysis.
"""

import os
import sys
import pefile
import subprocess
import math
import yara
import argparse
from collections import Counter

class RansomwareScanner:
    def __init__(self, rules_path="rules1.yar"):
        """Initialize the scanner with YARA rules."""
        try:
            self.rules = yara.compile(rules_path)
            print(f"[+] Successfully loaded YARA rules from {rules_path}")
        except Exception as e:
            print(f"[-] Error loading YARA rules: {e}")
            sys.exit(1)
        
        # Suspicious DLL imports we're looking for
        self.suspicious_dlls = {
            'crypto': ['bcrypt.dll', 'ncrypt.dll', 'crypt32.dll', 'advapi32.dll'],
            'filesystem': ['kernel32.dll', 'shell32.dll', 'shlwapi.dll', 'ntdll.dll', 'ole32.dll'],
            'network': ['wininet.dll', 'winhttp.dll', 'ws2_32.dll', 'urlmon.dll', 'dnsapi.dll', 'httpapi.dll']
        }
        
        # Suspicious functions we're looking for
        self.suspicious_functions = {
            'file_enum': ['FindFirstFile', 'FindNextFile', 'FindClose', 'GetLogicalDrives', 'GetDriveType'],
            'file_ops': ['CreateFile', 'ReadFile', 'WriteFile', 'DeleteFile', 'RemoveDirectory', 'SetFileAttributes'],
            'crypto': ['CryptAcquireContext', 'CryptGenKey', 'CryptEncrypt', 'CryptDecrypt', 
                      'BCryptEncrypt', 'BCryptGenRandom'],
            'anti_debug': ['IsDebuggerPresent', 'CheckRemoteDebuggerPresent', 'NtQueryInformationProcess',
                          'GetTickCount', 'QueryPerformanceCounter', 'Sleep'],
            'system_mod': ['RegOpenKey', 'RegSetValue', 'RegCreateKey', 'CreateService', 
                          'OpenService', 'StartService'],
            'injection': ['VirtualAlloc', 'VirtualAllocEx', 'WriteProcessMemory', 'CreateRemoteThread']
        }
        
        # Suspicious strings for ransomware
        self.ransom_note_keywords = [
            'encrypted', 'decrypt', 'bitcoin', 'payment', 'pay', 'ransom', 'files', 
            'hours', 'before', 'delete', 'forever', 'recover', 'wallet', 'btc', 'monero', 'xmr'
        ]
        
        self.suspicious_extensions = [
            '.encrypted', '.locked', '.crypt', '.payforunlock', '.fun', '.pay', 
            '.crypto', '.ransom', '.enc'
        ]
        
        self.target_extensions = [
            '.txt', '.doc', '.docx', '.xls', '.xlsx', '.pdf', '.jpg', '.jpeg', '.png', 
            '.zip', '.rar', '.csv', '.ppt', '.pptx'
        ]
        
        self.anti_recovery_commands = [
            'vssadmin delete shadows',
            'bcdedit /set {default} recoveryenabled no',
            'wbadmin delete catalog',
            'wmic shadowcopy delete',
            'cipher /w'
        ]

    def extract_imports(self, exe_path):
        """Extract imported DLLs and functions from the executable."""
        try:
            pe = pefile.PE(exe_path)
            
            imports = {}
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode('utf-8', errors='ignore').lower()
                    functions = []
                    for imp in entry.imports:
                        if imp.name:
                            func_name = imp.name.decode('utf-8', errors='ignore')
                            functions.append(func_name)
                    imports[dll_name] = functions
            
            return imports
        except Exception as e:
            print(f"[-] Error extracting imports: {e}")
            return {}

    def extract_section_names(self, exe_path):
        """Extract section names from the executable."""
        try:
            pe = pefile.PE(exe_path)
            sections = [section.Name.decode('utf-8', errors='ignore').strip('\x00') 
                      for section in pe.sections]
            return sections
        except Exception as e:
            print(f"[-] Error extracting section names: {e}")
            return []

    def extract_strings(self, exe_path):
        """Extract strings from the executable using the 'strings' command."""
        try:
            # Execute strings command
            output = subprocess.check_output(["strings", exe_path], 
                                           stderr=subprocess.DEVNULL)
            # Decode and split the output
            strings_list = output.decode('utf-8', errors='ignore').split('\n')
            return strings_list
        except Exception as e:
            print(f"[-] Error extracting strings: {e}")
            print("[*] Trying alternative string extraction method...")
            
            # Backup method if 'strings' command fails
            try:
                with open(exe_path, 'rb') as f:
                    binary_data = f.read()
                
                result = []
                current_string = ""
                for byte in binary_data:
                    if 32 <= byte <= 126:  # Printable ASCII
                        current_string += chr(byte)
                    else:
                        if len(current_string) >= 4:  # Only keep strings of 4+ chars
                            result.append(current_string)
                        current_string = ""
                
                if len(current_string) >= 4:
                    result.append(current_string)
                
                return result
            except Exception as e2:
                print(f"[-] Alternative string extraction failed: {e2}")
                return []

    def calculate_entropy(self, exe_path):
        """Calculate Shannon entropy of the file."""
        try:
            with open(exe_path, 'rb') as f:
                data = f.read()
            
            if not data:
                return 0
            
            # Count byte frequencies
            byte_counts = Counter(data)
            file_size = len(data)
            
            # Calculate entropy
            entropy = 0
            for count in byte_counts.values():
                probability = count / file_size
                entropy -= probability * math.log2(probability)
            
            return entropy
        except Exception as e:
            print(f"[-] Error calculating entropy: {e}")
            return 0

    def analyze_file(self, exe_path):
        """Perform comprehensive analysis of the executable."""
        results = {
            'file_path': exe_path,
            'file_size': os.path.getsize(exe_path),
            'yara_matches': [],
            'suspicious_imports': {
                'crypto': 0,
                'filesystem': 0,
                'network': 0
            },
            'suspicious_functions': {
                'file_enum': 0,
                'file_ops': 0,
                'crypto': 0,
                'anti_debug': 0,
                'system_mod': 0,
                'injection': 0
            },
            'suspicious_strings': {
                'ransom_notes': 0,
                'file_extensions': 0,
                'target_extensions': 0,
                'anti_recovery': 0
            },
            'entropy': 0,
            'unusual_sections': False,
            'score': 0
        }
        
        # YARA scanning
        print("[*] Running YARA rules scan...")
        try:
            matches = self.rules.match(exe_path)
            for match in matches:
                results['yara_matches'].append(match.rule)
            print(f"[+] YARA matches: {len(matches)}")
        except Exception as e:
            print(f"[-] YARA scanning error: {e}")
        
        # Entropy calculation
        print("[*] Calculating file entropy...")
        entropy = self.calculate_entropy(exe_path)
        results['entropy'] = entropy
        print(f"[+] File entropy: {entropy:.2f}")
        
        # Imports analysis
        print("[*] Analyzing imported DLLs and functions...")
        imports = self.extract_imports(exe_path)
        
        # Check for suspicious DLLs
        for category, dll_list in self.suspicious_dlls.items():
            for dll in dll_list:
                if any(dll.lower() in import_dll.lower() for import_dll in imports.keys()):
                    results['suspicious_imports'][category] += 1
        
        # Check for suspicious functions
        for category, func_list in self.suspicious_functions.items():
            for func in func_list:
                for dll_functions in imports.values():
                    if any(func in function for function in dll_functions):
                        results['suspicious_functions'][category] += 1
        
        # Section names analysis
        print("[*] Analyzing section names...")
        sections = self.extract_section_names(exe_path)
        standard_sections = ['.text', '.rdata', '.data', '.rsrc', '.reloc', '.idata', 
                            '.edata', '.tls', '.bss', '.pdata', '.CRT', '.rodata']
        
        for section in sections:
            if section and section not in standard_sections:
                results['unusual_sections'] = True
                break
        
        # Strings analysis
        print("[*] Analyzing strings in the executable...")
        strings_list = self.extract_strings(exe_path)
        
        # Check for ransom note keywords
        for keyword in self.ransom_note_keywords:
            for string in strings_list:
                if keyword.lower() in string.lower():
                    results['suspicious_strings']['ransom_notes'] += 1
                    break
        
        # Check for suspicious extensions
        for ext in self.suspicious_extensions:
            for string in strings_list:
                if ext.lower() in string.lower():
                    results['suspicious_strings']['file_extensions'] += 1
                    break
        
        # Check for target extensions
        extension_count = 0
        for ext in self.target_extensions:
            for string in strings_list:
                if ext.lower() in string.lower():
                    extension_count += 1
                    break
        
        # If there are more than 5 target extensions, it's suspicious
        if extension_count >= 5:
            results['suspicious_strings']['target_extensions'] = extension_count
        
        # Check for anti-recovery commands
        for cmd in self.anti_recovery_commands:
            for string in strings_list:
                if cmd.lower() in string.lower():
                    results['suspicious_strings']['anti_recovery'] += 1
                    break
        
        # Calculate overall score based on findings
        score = 0
        
        # YARA matches score (0-40)
        score += len(results['yara_matches']) * 10
        
        # Imports score (0-15)
        imports_score = (results['suspicious_imports']['crypto'] * 2 + 
                         results['suspicious_imports']['filesystem'] + 
                         results['suspicious_imports']['network'] * 2)
        score += min(imports_score, 15)
        
        # Functions score (0-20)
        functions_score = (results['suspicious_functions']['file_enum'] +
                          results['suspicious_functions']['file_ops'] +
                          results['suspicious_functions']['crypto'] * 2 +
                          results['suspicious_functions']['anti_debug'] +
                          results['suspicious_functions']['system_mod'] +
                          results['suspicious_functions']['injection'])
        score += min(functions_score, 20)
        
        # Strings score (0-15)
        strings_score = (results['suspicious_strings']['ransom_notes'] +
                         results['suspicious_strings']['file_extensions'] * 2 +
                         results['suspicious_strings']['target_extensions'] // 3 +
                         results['suspicious_strings']['anti_recovery'] * 3)
        score += min(strings_score, 15)
        
        # Entropy score (0-5)
        if 7.0 <= entropy <= 8.0:  # Very high entropy suggesting encryption or packing
            score += 5
        elif 6.5 <= entropy < 7.0:
            score += 3
        
        # Unusual sections (0-5)
        if results['unusual_sections']:
            score += 5
        
        results['score'] = score
        
        return results

    def scan_executable(self, exe_path):
        """Scan an executable file and determine if it's ransomware."""
        if not os.path.isfile(exe_path):
            print(f"[-] Error: {exe_path} is not a valid file")
            return False
        
        print(f"[*] Scanning {exe_path}...")
        results = self.analyze_file(exe_path)
        
        # Print detailed analysis results
        print("\n[+] === ANALYSIS RESULTS ===")
        print(f"File: {results['file_path']}")
        print(f"Size: {results['file_size']:,} bytes")
        print(f"Entropy: {results['entropy']:.2f} (Normal: ~4.5-6.5, Packed/Encrypted: ~7.0-8.0)")
        
        print("\nYARA Matches:")
        if results['yara_matches']:
            for rule in results['yara_matches']:
                print(f"  - {rule}")
        else:
            print("  - None")
        
        print("\nSuspicious Imports:")
        for category, count in results['suspicious_imports'].items():
            print(f"  - {category.capitalize()}: {count}")
        
        print("\nSuspicious Functions:")
        for category, count in results['suspicious_functions'].items():
            print(f"  - {category.capitalize().replace('_', ' ')}: {count}")
        
        print("\nSuspicious Strings:")
        for category, count in results['suspicious_strings'].items():
            print(f"  - {category.capitalize().replace('_', ' ')}: {count}")
        
        print(f"\nUnusual Section Names: {'Yes' if results['unusual_sections'] else 'No'}")
        
        print(f"\n[+] Final Score: {results['score']}/100")
        
        # Determine if it's ransomware based on score
        if results['score'] >= 70:
            print("\n[!] VERDICT: HIGH PROBABILITY OF RANSOMWARE")
            return True
        elif results['score'] >= 40:
            print("\n[!] VERDICT: MEDIUM PROBABILITY OF RANSOMWARE")
            return True
        else:
            print("\n[+] VERDICT: LOW PROBABILITY OF RANSOMWARE")
            return False


def main():
    """Main function to parse arguments and run the scanner."""
    parser = argparse.ArgumentParser(description="Ransomware Scanner - Detect potential ransomware executables")
    parser.add_argument("exe_path", help="Path to the executable file to scan")
    parser.add_argument("--rules", "-r", default="rules.yar", help="Path to YARA rules file (default: rules.yar)")
    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose output")
    
    args = parser.parse_args()
    
    print("====================================")
    print("=== Ransomware Scanner ===")
    print("====================================")
    
    scanner = RansomwareScanner(args.rules)
    result = scanner.scan_executable(args.exe_path)
    
    sys.exit(0 if not result else 1)


if __name__ == "__main__":
    main()