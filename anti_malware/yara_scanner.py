import os
import yara
import os
from ctypes import cdll

import sys
def is_pe_file(file_path):
    """
    Checks if a file is a valid Windows PE executable.
    
    Args:
        file_path (str): Path to the file.
        
    Returns:
        bool: True if the file is a PE executable, False otherwise.
    """
    try:
        with open(file_path, 'rb') as f:
            # Read the first 2 bytes to check for the MZ signature
            header = f.read(2)
            if header != b'MZ':
                print(f"File {file_path} is not a valid PE file (missing MZ header).")
                return False
                
            # Seek to the PE header offset location
            f.seek(0x3C)
            pe_offset_bytes = f.read(4)
            pe_offset = int.from_bytes(pe_offset_bytes, byteorder='little')
            
            # Check for the PE signature
            f.seek(pe_offset)
            pe_sig = f.read(4)
            if pe_sig != b'PE\x00\x00':
                print(f"File {file_path} is not a valid PE file (missing PE signature).")
                return False
                
            return True
    except Exception as e:
        print(f"Error checking if {file_path} is a PE file: {e}")
        return False
def resource_path(relative_path):
    """
    Get the absolute path to a resource, works for PyInstaller and during development.
    """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)

# Set the path to libyara.dll
# os.environ["PATH"] += ";C:\\path\\to\\libyara.dll"
# cdll.LoadLibrary("libyara.dll")
def compile_yara_rules(rule_file):
    """
    Compiles YARA rules from a file.

    Args:
        rule_file (str): Path to the YARA rule file.

    Returns:
        yara.Rules: Compiled YARA rules.
    """
    try:
        # Use resource_path to locate the rules file
        rule_file_path = resource_path(rule_file)
        return yara.compile(filepath=rule_file_path)
    except yara.Error as e:
        print(f"Error compiling YARA rules: {e}")
        raise

def scan_file_with_yara(rules, file_path):
    """
    Scans a file using YARA rules and calculates a total score.

    Args:
        rules (yara.Rules): Compiled YARA rules.
        file_path (str): Path to the file to scan.

    Returns:
        tuple: Total score and a list of matched rules.
    """
    try:
        matches = rules.match(file_path)
        total_score = 0
        matched_rules = []

        for match in matches:
            score = int(match.meta.get("score", 0))  # Get the score from the rule's metadata
            total_score += score
            matched_rules.append((match.rule, score, match.meta.get("category", "Unknown")))

        return total_score, matched_rules
    except Exception as e:
        print(f"Error scanning file {file_path}: {e}")
        return 0, []

def list_exe_files(directory):
    """
    Lists all valid .exe files (PE files) in the specified directory.

    Args:
        directory (str): The directory to scan for .exe files.

    Returns:
        list: A list of valid .exe file paths.
    """
    print(f"Scanning directory: {directory}")  # Debugging output
    exe_files = []
    for file in os.listdir(directory):
        full_path = os.path.join(directory, file)
        if file.endswith(".exe") and is_pe_file(full_path):
            exe_files.append(full_path)
    return exe_files
def main():
    base_dir = os.getcwd()    
    print(base_dir)
    # Path to the YARA rule file
    yara_rule_file = resource_path("ransomware_rules.yar")

    # Compile YARA rules
    rules = compile_yara_rules(yara_rule_file)
    if not rules:
        print("Failed to compile YARA rules. Exiting.")
        return

    # Get the directory where the script is located
    

    # List all files in the directory for debugging
    print(f"Files in directory: {base_dir}")
    try:
        for item in os.listdir(base_dir):
            item_path = os.path.join(base_dir, item)
            item_type = "Directory" if os.path.isdir(item_path) else "File"
            print(f" - {item} ({item_type})")
    except Exception as e:
        print(f"Error listing directory contents: {e}")
        return

    # List all valid .exe files in the directory
    exe_files = list_exe_files(base_dir)

    # Define a threshold score for flagging ransomware
    threshold_score = 50

    if exe_files:
        print("Scanning valid .exe files (PE files) with YARA...")
        for exe in exe_files:
            total_score, matched_rules = scan_file_with_yara(rules, exe)

            print(f"\nFile: {exe}")
            print(f"Total Score: {total_score}")
            if matched_rules:
                print("Matched Rules:")
                for rule, score, category in matched_rules:
                    print(f" - Rule: {rule}, Score: {score}, Category: {category}")

            if total_score >= threshold_score:
                print("Result: Suspicious (Potential Ransomware)")
            else:
                print("Result: Benign")
    else:
        print("No valid .exe files (PE files) found in the directory.")
    print(f"Using YARA rules file at: {resource_path('ransomware_rules.yar')}")
    print(f"Current working directory: {os.getcwd()}")

if __name__ == "__main__":
    main()


# import math

# def calculate_entropy(file_path):
#     with open(file_path, "rb") as f:
#         data = f.read()
#     if not data:
#         return 0
#     byte_counts = [0] * 256
#     for byte in data:
#         byte_counts[byte] += 1
#     entropy = -sum((count / len(data)) * math.log2(count / len(data)) for count in byte_counts if count > 0)
#     return entropy

# # Example usage
# entropy = calculate_entropy("example.exe")
# print(f"Entropy: {entropy}")    