import os

import pefile


def score_dll_imports(imports):
    """
    Scores the DLL imports of an executable to predict ransomware-like behavior.

    Args:
        imports (list): A list of dictionaries containing DLL names and their imported functions.

    Returns:
        int: A score representing the likelihood of ransomware-like behavior.
    """
    # Define suspicious DLLs and their categories
    suspicious_dlls = {
        "Crypto": [
    "bcrypt.dll",
    "bcryptprimitives.dll",
    "ncrypt.dll",
    "crypt32.dll",
    "cryptbase.dll",
    "cryptui.dll",
    "advapi32.dll",
    "rsaenh.dll",
    "msasn1.dll",
    "wincrypt.dll",
    "secur32.dll",
    "sspicli.dll",
    "schannel.dll",
    "dpapi.dll",
    "pku2u.dll",
    "kerberos.dll",
    "netapi32.dll",
    "lsasrv.dll",
    "samsrv.dll",
    "vaultcli.dll",
    "credui.dll",
    "tokenbinding.dll",
    "trustdll.dll",
    "tbs.dll",
    "kmsvc.dll",
    "slc.dll",
    "slcd.dll",
    "licensingdiag.dll"
],


        "FileSystem": ["kernel32.dll", "shell32.dll","wow64.dl","fltlib.dll","msvcrt.dll","windows.storage.dll","propsys.dll","advapi32.dll", "shlwapi.dll", "user32.dll","comdlg32.dll","ntdll.dll", "ole32.dll","combase.dll"],
        "Internet": ["wininet.dll", "winhttp.dll", "ws2_32.dll", "urlmon.dll", "httpapi.dll", "dnsapi.dll"],
    }

    # Initialize score
    score = 0

    # Check each DLL in the imports
    for entry in imports:
        dll_name = entry["DLL"].lower()
        for category, dll_list in suspicious_dlls.items():
            if dll_name in dll_list:
                print(f"Suspicious DLL detected: {dll_name} (Category: {category})")
                score += 10  # Assign points for each suspicious DLL

    return score



def analyze_exe(file_path):
    """
    Analyzes the metadata and imports of a given .exe file.

    Args:
        file_path (str): Path to the .exe file.

    Returns:
        dict: A dictionary containing metadata and imports of the .exe file.
    """
    try:
        pe = pefile.PE(file_path)
        metadata = {
            "File": file_path,
            "Machine": hex(pe.FILE_HEADER.Machine),
            "Number of Sections": pe.FILE_HEADER.NumberOfSections,
            "Time Date Stamp": pe.FILE_HEADER.TimeDateStamp,
            "Entry Point": hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint),
            "Image Base": hex(pe.OPTIONAL_HEADER.ImageBase),
            "Sections": [section.Name.decode().strip() for section in pe.sections],
        }

        # Extract imports
        imports = []
        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode()
                functions = []
                for imp in entry.imports:
                    if imp.name:
                        functions.append(imp.name.decode())
                    else:
                        functions.append(f"Ordinal_{imp.ordinal}")
                imports.append({"DLL": dll_name, "Functions": functions})
        metadata["Imports"] = imports

        return metadata
    except Exception as e:
        return {"File": file_path, "Error": str(e)}



def list_exe_files(directory):
    """
    Lists all .exe files in the specified directory.

    Args:
        directory (str): The directory to scan for .exe files.

    Returns:
        list: A list of .exe file paths.
    """
    exe_files = []
    for file in os.listdir(directory):
        if file.endswith(".exe"):
            exe_files.append(os.path.join(directory, file))
    return exe_files

def main():
    # Get the directory where the script is located
    base_dir = os.path.dirname(os.path.abspath(__file__))

    # List all .exe files in the directory
    exe_files = list_exe_files(base_dir)

    if exe_files:
        print("Analyzing .exe files...")
        for exe in exe_files:
            file_path = os.path.join(base_dir, exe)
            metadata = analyze_exe(file_path)
            print(metadata)
    else:
        print("No .exe files found in the directory.")

if __name__ == "__main__":
    main()