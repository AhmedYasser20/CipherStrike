import os
import yara
import os
from ctypes import cdll

import sys


import math

def calculate_entropy(file_path):
    """
    Calculate the Shannon entropy of a file.
    Higher values (closer to 8.0) suggest encryption or compression.
    
    Args:
        file_path (str): Path to the file.
        
    Returns:
        float: Entropy value between 0 and 8.
    """
    try:
        with open(file_path, "rb") as f:
            data = f.read()
        if not data:
            return 0
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        entropy = -sum((count / len(data)) * math.log2(count / len(data)) 
                      for count in byte_counts if count > 0)
        return entropy
    except Exception as e:
        print(f"Error calculating entropy: {e}")
        return 0
def is_pe_file(file_path):
    """
    Checks if a file is a valid Windows PE executable.
    
    Args:
        file_path (str): Path to the file.
        
    Returns:
        bool: True if the file is a PE executable, False otherwise.
    """
    try:
        with open(file_path, 'rb') as f:
            # Read the first 2 bytes to check for the MZ signature
            header = f.read(2)
            if header != b'MZ':
                print(f"File {file_path} is not a valid PE file (missing MZ header).")
                return False
                
            # Seek to the PE header offset location
            f.seek(0x3C)
            pe_offset_bytes = f.read(4)
            pe_offset = int.from_bytes(pe_offset_bytes, byteorder='little')
            
            # Check for the PE signature
            f.seek(pe_offset)
            pe_sig = f.read(4)
            if pe_sig != b'PE\x00\x00':
                print(f"File {file_path} is not a valid PE file (missing PE signature).")
                return False
                
            return True
    except Exception as e:
        print(f"Error checking if {file_path} is a PE file: {e}")
        return False
def resource_path(relative_path):
    """
    Get the absolute path to a resource, works for PyInstaller and during development.
    """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)

# Set the path to libyara.dll
# os.environ["PATH"] += ";C:\\path\\to\\libyara.dll"
# cdll.LoadLibrary("libyara.dll")
def compile_yara_rules(rule_file):
    """
    Compiles YARA rules from a file.

    Args:
        rule_file (str): Path to the YARA rule file.

    Returns:
        yara.Rules: Compiled YARA rules.
    """
    try:
        # Use resource_path to locate the rules file
        rule_file_path = resource_path(rule_file)
        return yara.compile(filepath=rule_file_path)
    except yara.Error as e:
        print(f"Error compiling YARA rules: {e}")
        raise
def is_ransomware(file_path, rules):
    """
    Makes a binary decision (TRUE/FALSE) if the file is ransomware.
    """
    try:
        # Get the filename only for whitelist checking
        filename = os.path.basename(file_path).lower()
        
        # Common developer tools to exclude
        dev_tools = ['ninja.exe', 'cmake.exe', 'msbuild.exe', 'make.exe', 'gcc.exe', 'python.exe', 'clang.exe']
        if filename in dev_tools:
            return False, set(), "Whitelist: Developer tool"
            
        # Calculate entropy of the file
        entropy = calculate_entropy(file_path)
        
        # Match YARA rules
        matches = rules.match(file_path)
        matched_rules = set(match.rule for match in matches)
        
        # Check for developer tools rule match
        if "Developer_Tools" in matched_rules:
            return False, matched_rules, "Whitelist: Developer tool (rule match)"
            
        # Direct pattern match for ransomware
        if "Is_Ransomware" in matched_rules:
            return True, matched_rules, "Pattern match"
            
        # Calculate score from matched rules
        scores = {
            "Group_Basic_System_DLLs": 3,
            "Group_Cryptographic_Capabilities": 12,
            "Group_File_Manipulation": 18,
            "Group_Anti_Analysis_Techniques": 25,
            "Group_Direct_Ransomware_Indicators": 35
        }
        
        # Calculate total score
        total_score = sum(scores.get(rule_name, 0) for rule_name in matched_rules)
        
        # Add entropy score
        if entropy > 7.5:  # Very high entropy
            total_score += 15
            entropy_factor = "Very high entropy"
        elif entropy > 7.0:  # High entropy
            total_score += 8
            entropy_factor = "High entropy"
        elif entropy > 6.7:  # Moderately high entropy
            total_score += 3
            entropy_factor = "Moderate entropy"
        else:
            entropy_factor = "Normal entropy"
        
        # Add combination bonuses
        crypto_and_file = "Group_Cryptographic_Capabilities" in matched_rules and "Group_File_Manipulation" in matched_rules
        if crypto_and_file:
            total_score += 5
            
        anti_analysis_and_crypto = "Group_Anti_Analysis_Techniques" in matched_rules and "Group_Cryptographic_Capabilities" in matched_rules
        if anti_analysis_and_crypto:
            total_score += 8
        
        # INCREASED threshold to reduce false positives
        return total_score >= 75, matched_rules, f"Score: {total_score}"
        
    except Exception as e:
        print(f"Error analyzing file {file_path}: {e}")
        return False, set(), f"Error: {e}"

def scan_file_with_yara(rules, file_path):
    """
    Scans a file using YARA rules and determines if it's ransomware.
    Also calculates file entropy as an additional indicator.

    Args:
        rules (yara.Rules): Compiled YARA rules.
        file_path (str): Path to the file to scan.

    Returns:
        tuple: (is_ransomware, matched_rules, total_score, entropy)
    """
    try:
        matches = rules.match(file_path)
        
        # Calculate file entropy
        entropy = calculate_entropy(file_path)
        
        # Check if the Is_Ransomware rule matched directly
        is_ransomware_direct = any(match.rule == "Is_Ransomware" for match in matches)
        
        # Apply scoring system regardless of direct match
        is_ransomware_by_score_result = is_ransomware_by_score(matches)
        
        # Consider high entropy (> 7.0) as an additional risk factor
        high_entropy = entropy > 7.0
        
        # Combine results (either method can identify ransomware)
        is_ransomware = is_ransomware_direct or is_ransomware_by_score_result
        
        # Prepare details about matched rules for reporting
        matched_rules = []
        total_score = 0
        
        for match in matches:
            score = 0
            if match.rule == "Group_Basic_System_DLLs":
                score = 5
            elif match.rule == "Group_Cryptographic_Capabilities":
                score = 15
            elif match.rule == "Group_File_Manipulation":
                score = 20
            elif match.rule == "Group_Anti_Analysis_Techniques":
                score = 25
            elif match.rule == "Group_Direct_Ransomware_Indicators":
                score = 40
                
            matched_rules.append((match.rule, score))
            total_score += score
        
        # Add additional points for high entropy
        if high_entropy:
            total_score += 10
            matched_rules.append(("High_Entropy", 10))
        
        # Update the threshold check based on the new scoring
        is_ransomware_by_score_threshold = total_score >= 60
        is_ransomware = is_ransomware_direct or is_ransomware_by_score_threshold
        
        return is_ransomware, matched_rules, total_score, entropy
        
    except Exception as e:
        print(f"Error scanning file {file_path}: {e}")
        return False, [], 0, 0

def list_exe_files(directory):
    """
    Lists all valid .exe files (PE files) in the specified directory.

    Args:
        directory (str): The directory to scan for .exe files.

    Returns:
        list: A list of valid .exe file paths.
    """
    print(f"Scanning directory: {directory}")  # Debugging output
    exe_files = []
    for file in os.listdir(directory):
        full_path = os.path.join(directory, file)
        if file.endswith(".exe") and is_pe_file(full_path):
            exe_files.append(full_path)
    return exe_files
def main():
    # Get the directory where the executable is being run
    base_dir = os.getcwd()
    print(f"Scanning directory: {base_dir}")

    # Path to the YARA rule file
    yara_rule_file = resource_path("rules.yar")

    # Compile YARA rules
    rules = compile_yara_rules(yara_rule_file)
    if not rules:
        print("Failed to compile YARA rules. Exiting.")
        return

    # List all valid .exe files in the directory
    exe_files = list_exe_files(base_dir)

    if exe_files:
        print("Scanning files for ransomware...")
        for exe in exe_files:
            result, matched_rules, reason = is_ransomware(exe, rules)
            
            print(f"\nFile: {exe}")
            entropy = calculate_entropy(exe)
            print(f"Entropy: {entropy:.6f}")
            
            # Show matched rules for debugging
            if matched_rules:
                print("Matched rules:")
                for rule in matched_rules:
                    print(f" - {rule}")
            
            # Binary decision output with reason
            if result:
                print(f"RESULT: RANSOMWARE [TRUE] - {reason}")
            else:
                print(f"RESULT: NOT RANSOMWARE [FALSE] - {reason}")
    else:
        print("No valid .exe files found in the directory.")

if __name__ == "__main__":
    main()


# import math

# def calculate_entropy(file_path):
#     with open(file_path, "rb") as f:
#         data = f.read()
#     if not data:
#         return 0
#     byte_counts = [0] * 256
#     for byte in data:
#         byte_counts[byte] += 1
#     entropy = -sum((count / len(data)) * math.log2(count / len(data)) for count in byte_counts if count > 0)
#     return entropy

# # Example usage
# entropy = calculate_entropy("example.exe")
# print(f"Entropy: {entropy}")    