import os
import yara
import sys
import argparse
from ctypes import cdll

def compile_yara_rules(rule_file):
    """
    Compiles YARA rules from a file.

    Args:
        rule_file (str): Path to the YARA rule file.

    Returns:
        yara.Rules: Compiled YARA rules.
    """
    try:
        rules = yara.compile(filepath=rule_file)
        return rules
    except yara.SyntaxError as e:
        print(f"Error compiling YARA rules: {e}")
        return None

def scan_file_with_yara(rules, file_path):
    """
    Scans a file using YARA rules and calculates a total score.

    Args:
        rules (yara.Rules): Compiled YARA rules.
        file_path (str): Path to the file to scan.

    Returns:
        tuple: Total score and a list of matched rules.
    """
    try:
        matches = rules.match(file_path)
        total_score = 0
        matched_rules = []

        for match in matches:
            score = int(match.meta.get("score", 0))  # Get the score from the rule's metadata
            total_score += score
            matched_rules.append((match.rule, score, match.meta.get("category", "Unknown")))

        return total_score, matched_rules
    except Exception as e:
        print(f"Error scanning file {file_path}: {e}")
        return 0, []

def list_target_files(directory, extensions=None):
    """
    Lists files in the specified directory, optionally filtered by extensions.

    Args:
        directory (str): The directory to scan for files.
        extensions (list, optional): List of file extensions to filter by (e.g., ['.exe', '.dll']).
                                    If None, all files are included.

    Returns:
        list: A list of file paths.
    """
    if not os.path.exists(directory):
        print(f"Directory not found: {directory}")
        return []

    files = []
    for item in os.listdir(directory):
        full_path = os.path.join(directory, item)
        # Skip directories
        if os.path.isdir(full_path):
            continue
        # Apply extension filter if provided
        if extensions is None or any(item.lower().endswith(ext.lower()) for ext in extensions):
            files.append(full_path)
    return files
def is_pe_file(file_path):
    """
    Checks if a file is a valid Windows PE executable.
    
    Args:
        file_path (str): Path to the file.
        
    Returns:
        bool: True if the file is a PE executable, False otherwise.
    """
    try:
        with open(file_path, 'rb') as f:
            # Read the first 2 bytes to check for MZ signature
            header = f.read(2)
            if header != b'MZ':
                return False
                
            # Seek to the PE header offset location
            f.seek(0x3C)
            pe_offset_bytes = f.read(4)
            pe_offset = int.from_bytes(pe_offset_bytes, byteorder='little')
            
            # Check for the PE signature
            f.seek(pe_offset)
            pe_sig = f.read(4)
            if pe_sig != b'PE\x00\x00':
                return False
                
            return True
    except Exception as e:
        print(f"Error checking if {file_path} is a PE file: {e}")
        return False

        import os
import sys

# Determine if we're running as bundled app or as a normal Python script
def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

# Use resource_path when accessing the rules file
# Example: yara_rule_file = resource_path(args.rules)
def main():
    # Existing argument parsing code...
    
    # Print diagnostic information
    print(f"Scanning directory: {args.directory}")
    
    # Determine files to scan
    files_to_scan = []
    if args.file:
        if os.path.isfile(args.file):
            files_to_scan = [args.file]
        else:
            print(f"File not found: {args.file}")
            return
    else:
        # Get files from directory
        extensions = None if args.all_files else args.extensions
        files_to_scan = list_target_files(args.directory, extensions)
        
        # Show found files for debugging
        print(f"Found {len(files_to_scan)} files with extension(s): {extensions or 'all'}")
        if len(files_to_scan) == 0:
            print("Files in directory:")
            try:
                for item in os.listdir(args.directory):
                    item_path = os.path.join(args.directory, item)
                    item_type = "Directory" if os.path.isdir(item_path) else "File"
                    print(f" - {item} ({item_type})")
            except Exception as e:
                print(f"Error listing directory contents: {e}")

    # Define threshold score for flagging suspicious files
    threshold_score = 60

    if files_to_scan:
        print(f"Scanning {len(files_to_scan)} files with YARA...")
        suspicious_count = 0
        benign_count = 0
        skipped_count = 0
        
        for file_path in files_to_scan:
            # Check if the file is a PE executable when scanning for .exe files
            if args.extensions == [".exe"] and not is_pe_file(file_path):
                print(f"\nFile: {file_path}")
                print("Result: Skipped (Not a valid PE executable)")
                skipped_count += 1
                continue
                
            # Print file being scanned
            print(f"\nScanning: {file_path}")
            
            total_score, matched_rules = scan_file_with_yara(rules, file_path)
            
            print(f"Total Score: {total_score}")
            if matched_rules:
                print("Matched Rules:")
                for rule, score, category in matched_rules:
                    print(f" - Rule: {rule}, Score: {score}, Category: {category}")

            if total_score >= threshold_score:
                print("Result: Suspicious (Potential Malware)")
                suspicious_count += 1
            else:
                print("Result: Benign")
                benign_count += 1
            
        print(f"\nScan Summary:")
        print(f"Total files scanned: {len(files_to_scan) - skipped_count}")
        print(f"Suspicious files: {suspicious_count}")
        print(f"Benign files: {benign_count}")
        print(f"Skipped files: {skipped_count}")
    else:
        print(f"No files found to scan in {args.directory}")

if __name__ == "__main__":
    main()


# Uncommented entropy calculation code for reference
# import math

# def calculate_entropy(file_path):
#     with open(file_path, "rb") as f:
#         data = f.read()
#     if not data:
#         return 0
#     byte_counts = [0] * 256
#     for byte in data:
#         byte_counts[byte] += 1
#     entropy = -sum((count / len(data)) * math.log2(count / len(data)) for count in byte_counts if count > 0)
#     return entropy